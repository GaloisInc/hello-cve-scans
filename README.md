# Introduction

This repository contains minimal Python, Rust, and Haskell projects
that provide hello-world-ish projects where we can demonstrate and
test the capabilities of CVE scan tools for these languages.

We also describe what github's dependabot can bring to the table
(generally not highly recommended, see below).

# Scanning for CVEs
## General Issues to Consider

Any audit/scan tool must deal with
 - dependency on the build tool
   - pkg constraints (manifest/spec/?) vs the actual packages used (in
     x.lock file)
   - do the  the oes the dependency specif. match the code
     - if 'dead' packages

 - transitive or not
   - not an issue if scan based on x.lock file that includes full set
     of dependencies

 - distinguishing dependencies
   - run-time
   - build-time, test-targets, other-targets

Ramifications / Best practices
 - build;cve-scan may not be deterministic:
   - depends on CVE db [way to capture?], should capture date
   - depends on the "package database"!
 - thus, ideally we should
   - build; commit x.lock file; cve-scan > _ (and add ?)
   -

Issues with "testing/exploring"
 - want to set pkg versions to exercise the scanner, but if build tool
   overrides, ugh.

Other issues
 - fine or coarse grained dependencies
 - practice of committing x.lock files to the repo.

**TODO:**

Causes of false positives (CVEs reported when not applicable)
 - coarse grain dependencies [...]
 - not taking architecture into account for CVEs that are architecture
   dependent (similar to the previous).
 - unused packages listed in _ file.
Causes of false negatives (CVE vulnerabilities that are not reported)
 - not checking the indirect dependencies
 - not re-running scan on up to date CVE database
 - HMMM: is it possible to have dependence in code (but not _ file)
   that is resolved??
Causes of either
 - audit tool looking at the _ file and making assumptions about the
   actual packages that get resolved by the build.

## Rust CVE Scanning with `cargo audit`

Let's start with CVE scanning for rust, the easiest case.
First, install the `cargo-audit` tool
```
   cargo install cargo-audit
```

To run it on our project, do
```
   cd rust-project/
   cargo update    # create/update the Cargo.lock.
   cargo audit
```
and you should then see
```
    Fetching advisory database from `https://github.com/RustSec/advisory-db.git`
      Loaded 645 security advisories (from /Users/tullsen/.cargo/advisory-db)
    Updating crates.io index
    Scanning Cargo.lock for vulnerabilities (7 crate dependencies)
Crate:     time
Version:   0.1.45
Title:     Potential segfault in the time crate
Date:      2020-11-18
ID:        RUSTSEC-2020-0071
URL:       https://rustsec.org/advisories/RUSTSEC-2020-0071
Severity:  6.2 (medium)
Solution:  Upgrade to >=0.2.23
Dependency tree:
time 0.1.45
└── rust-project 0.1.0

error: 1 vulnerability found!
```
The command returns an error code to indicate a CVE vulnerability has been found.
```
rust-project $ echo $?
1
```

See the (commented) `Cargo.toml` file: you can comment out the `time`
package and re-run `cargo audit` to see that it now determines there
are no known CVE vulnerabilities.

A few things to note here
 - `cargo audit` will call `cargo update` so you can dispense
    with the latter if you wish.
 - `cargo update` follows all crate dependencies and creates/updates
    the Cargo.toml, thus we find the indirect dependencies which may
    have CVE vulnerabilities.
 - when `cargo update` updates the `Cargo.lock` file, it can override
   crate versions specified in the `Cargo.toml` file as part of
   "dependency resolution".  This might be surprising, this is why
   our audit tool should use the `Cargo.lock` file.

## Python CVE Scanning with _

## Haskell CVE Scanning with _

# Dependabot
## ?

Also, we have provided a `.github/dependabot.yml` along with *...*

See file _X_ for a play by play of why we ...

## Thoughts on Dependabot

In light of above comments, we would recommend against dependabot as a
reliable source for CVE warnings.  I'd say dependabot is most useful
as
 - a very low overhead [turn on in github.com] cve check
that works best for
 - supported languages
 - single package per repo, using the standard [for the language]
   build mechanisms.

Can be useful for
 - autogenerated PRs that update pkg versions.
