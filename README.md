# Introduction

This repository contains minimal Python, Rust, and Haskell projects
that provide hello-world-ish projects where we can demonstrate and
test the capabilities of CVE scan tools for these languages.

We also describe what github's dependabot can bring to the table
(generally not highly recommended, see below).

# Scanning for CVEs
## General Issues to Consider

Any audit/scan tool must deal with
 - dependency on the build tool
   - pkg constraints (manifest/spec/?) vs the actual packages used (in
     x.lock file)
   - do the  the oes the dependency specif. match the code
     - if 'dead' packages

 - transitive or not
   - not an issue if scan based on x.lock file that includes full set
     of dependencies

 - distinguishing dependencies
   - run-time
   - build-time, test-targets, other-targets

Ramifications / Best practices
 - build;cve-scan may not be deterministic:
   - depends on CVE db [way to capture?], should capture date
   - depends on the "package database"!
 - thus, ideally we should
   - build; commit x.lock file; cve-scan > _ (and add ?)
   -

Issues with "testing/exploring"
 - want to set pkg versions to exercise the scanner, but if build tool
   overrides, ugh.

Other issues
 - fine or coarse grained dependencies
 - practice of committing x.lock files to the repo.

**TODO:**

Causes of false positives (CVEs reported when not applicable)
 - coarse grain dependencies [...]
 - not taking architecture into account for CVEs that are architecture
   dependent (similar to the previous).
 - unused packages listed in _ file.
Causes of false negatives (CVE vulnerabilities that are not reported)
 - not checking the indirect dependencies
 - not re-running scan on up to date CVE database
 - HMMM: is it possible to have dependence in code (but not _ file)
   that is resolved??
Causes of either
 - audit tool looking at the _ file and making assumptions about the
   actual packages that get resolved by the build.


# Language specific CVE Scanning

For each of our three languages, we attempted to pick the best option
for a CVE scan tool.

- Rust CVE scanning with `cargo-audit`:
  See [Rust CVE Scans](rust-project/README.md).

- Python CVE Scanning with `pip-audit`.
  See [Python CVE Scans](py-project/README.md).

- Haskell CVE Scanning with MangoIV's `cabal-audit`.
  See [Haskell CVE Scans](hs-project/README.md).

# Dependabot
## ?

Also, we have provided a `.github/dependabot.yml` along with *...*

See file _X_ for a play by play of why we ...

## Assessment of Dependabot

In light of above comments, we would recommend against dependabot as a
reliable source for CVE warnings.  I'd say dependabot is most useful
as
 - a very low overhead [turn on in github.com] cve check
that works best for
 - supported languages
 - single package per repo, using the default standard [for the language]
   build mechanisms.

Can be useful for
 - autogenerated PRs that update pkg versions.
